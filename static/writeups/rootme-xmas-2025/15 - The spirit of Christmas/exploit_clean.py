import numpy as np
from Crypto.Cipher import AES

class LFSR:
    def __init__(self, seed_int):
        self.state = [(seed_int >> i) & 1 for i in range(128)]
        self.taps = [0,13,18,28,37,42,59,65,71,83,84,103,107,108,114,121,127]
        for _ in range(256):
            self.clock()
    
    def _sum(self, L):
        s = 0
        for x in L:
            s ^= x
        return s
    
    def clock(self):
        b_127 = self._sum(self.state[p] for p in self.taps)
        self.state = self.state[1:] + [b_127]
    
    def unclock(self): # LFSR rewinding
        b_0 = self.state[127] ^ self._sum(self.state[p-1] for p in self.taps[1:]) # b(0) = b'(127) + b'(12) + ... + b'(120) + b'(126)
        self.state = [b_0] + self.state[:-1]
    
    def bit(self):
        b = self.state[0]
        self.clock()
        return b

def bits_from_bytes_MSB(b):
    bits = []
    for x in b:
        for k in range(7, -1, -1):
            bits.append((x >> k) & 1)
    return bits

def int_from_bits_MSB(bits):
    b = 0
    for bit in bits:
        b = (b<<1) | (1 & bit)
    return b

def bytes_from_bits_MSB(bits):
    out = bytearray()
    for i in range(0, len(bits), 8):
        out.append(int_from_bits_MSB(bits[i:i+8]))
    return bytes(out)

def build_columns(total_bits_needed): # cols[k][i] = LFSR(i) when seed = 2^k
    cols = []
    for k in range(128):
        l = LFSR(1 << k)
        seq = [l.bit() for _ in range(total_bits_needed)]
        cols.append(seq)
    return cols

def gauss_gf2(M, y): # Gaussian elimination over GF(2)
    M = M.copy()
    y = y.copy()
    h, w = M.shape

    row = 0
    for col in range(w):
        piv = np.where(M[row:, col])[0] # pivot
        if piv.size == 0:
            continue
        piv = piv[0] + row
    
        if piv != row: # swap pivot <-> row
            M[[row, piv]] = M[[piv, row]]
            y[row], y[piv] = y[piv], y[row]

        mask = M[:, col] & (np.arange(h) != row)
        elim = np.where(mask)[0]
        if elim.size: # elimination
            M[elim] ^= M[row]
            y[elim] ^= y[row]

        row += 1
        if row == h:
            break
    
    x = np.zeros(w, dtype=bool) # solution
    r = 0
    for col in range(w): # reconstructing the solution
        if r < h and M[r, col]:
            x[col] = y[r]
            r += 1

    return x

def recover_lfsr_state(out_hex):
    out = bytes.fromhex(out_hex)
    assert len(out) % 16 == 0
    m = len(out) // 16
    blocks = [out[i*16:(i+1)*16] for i in range(m)]

    xors = [ # XORing adjacents blocks to remove AES
        bytes(a ^ b for a, b in zip(blocks[i], blocks[i+1]))
        for i in range(m - 1)
    ]
    Ys = [bits_from_bytes_MSB(b) for b in xors] # bytes to bits
    cols = build_columns(m * 128) # Build the seed bits incidence matrix, with 128 bits calculated per block

    # Build the linear system M.x = Y
    rows = []
    rhs = []
    i = 0
    for Ybits in Ys:
        for j in range(128):
            coef = [(cols[k][128*i + j] ^ cols[k][128*i + 128 + j]) for k in range(128)]
            rows.append(coef)
            rhs.append(Ybits[j])
        i+=1

    M = np.array(rows, dtype=bool)
    Y = np.array(rhs, dtype=bool)

    lfsr_state = gauss_gf2(M, Y) # Gaussian elimination to solve the system

    return list(int(b) for b in lfsr_state)


#input = "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
out_hex = "7162bc31d64f722a899ca130dec78cac5ad4c8c2f4850365a40642380a038238999e82e4321c58144611f40cf2038731"
flag_ct_hex = "b553a7b41643097854c5915305a41954f1606c0a0e3c427903bc5f0777b1c22d3d9d2ac197c70054940b1a4e2134eb30" 

lfsr_state = recover_lfsr_state(out_hex) # Get LFSR state when generating output

# Rewind the state to get the seed (= state before the 256 initial clocks)
lfsr = LFSR(int_from_bits_MSB(lfsr_state))
for _ in range(256):
    lfsr.unclock()

seed = bytes_from_bits_MSB(lfsr.state) # convert bits to bytes
dec = AES.new(seed, AES.MODE_ECB).decrypt(bytes.fromhex(flag_ct_hex)) # Decode using found seed
print(dec)